(in-package :icfp2014)

;;; Emacs macro for copying the whole code:
;; (fset 'lambdaman [?\M-> ?\C-x ?\C-e ?\C-x ?\C-x ?\C-x ?\C-f ?/ ?t ?m ?p ?/ ?l ?a ?m ?b ?d ?a ?m ?a ?n ?. ?g ?c ?c return ?\C-x ?h ?\M-w ?\C-x ?k return])

(with-open-file (s "/tmp/lambdaman.gcc" :direction :output :if-exists :supersede)
  (let ((*standard-output* s))
    (gcc

;;; GCC code starts

(cons -1 step)
(return)

(def step (rev-dir world)
  (let* ((lman (cadr world))
         (xy (cadr lman))
         (best (best-value-dir world xy rev-dir)))
    (cons (reverse-dir best) best)))

(def cell (map xy)
  (nth (car xy) (nth (cdr xy) map)))
(def neighbors (map xy prev)
  (let ((candidates (cons (left xy) (cons (right xy) (cons (up xy) (cons (down xy) 0))))))
    (remove-if-not (lambda (pos)
                     (and (> (cell map pos) +wall+)
                          (not (pos= pos prev))))
                   candidates)))
(def best-value-dir (world xy rev-dir)
  (let* ((map (car world))
         (ghosts (caddr world))
         (fruit (cdddr world))
         (dirs (cons +left+ (cons +right+ (cons +up+ (cons +down+ 0)))))
         (not-walls (remove-if-not (lambda (dir)
                                     (> (cell map (movement xy dir)) +wall+))
                                   dirs))
         (candidates (mapcar (lambda (dir)
                               (cons dir (+ (try-pos map ghosts fruit (movement xy dir))
                                            (if (= dir rev-dir) -1 0))))
                             not-walls)))
    ;; (debug candidates)
    (first (reduce (lambda (a b)
                     (if (> (cdr a) (cdr b)) a b))
                   candidates))))
(def try-pos (map ghosts fruit pos)
  (let* ((ghost-positions (mapcar cadr ghosts))
         (ghost-vitalities (mapcar first ghosts))
         (eval (xy distance)
           (let ((value (cell map xy)))
             (if (and (< distance 4)
                      (any (lambda (gp) (pos= gp xy)) ghost-positions))
                 (/ -1000 distance)
                 (if (= value +empty+)
                     0
                     (if (= value +pill+)
                         (/ 10 distance)
                         (if (= value +power-pill+)
                             (/ 40 distance)
                             (if (and (= value +fruit-pos+) (> (/ fruit 127) distance))
                                 (/ 80 distance)
                                 0)))))))
         (try (xy prev-pos n)
           (if (> n 6)
               0                        ; don't want to check further
               (let* ((adjacent (neighbors map xy prev-pos))
                      (values (mapcar (lambda (p) (eval p n)) adjacent)))
                 (if (atom values)
                     0               ; nowhere to go in this direction
                     (let ((minval (reduce min values)))
                       (if (< minval 0)
                           minval
                           (let* ((maxval (reduce max values))
                                  (bests (mapcar (lambda (p)
                                                   (try p xy (+ n 1)))
                                                 adjacent))
                                  (minbests (reduce min bests)))
                             (if (< minbests 0)
                                 minbests
                                 (if (> maxval 0)
                                     maxval
                                     (reduce max bests)))))))))))
    (+ (eval pos 1)
       (try pos pos 1))))

(def pos= (a b)
  (and (= (car a) (car b))
       (= (cdr a) (cdr b))))
(def reverse-dir (dir)
  (if (> dir 1)
      (- dir 2)
      (+ dir 2)))
(def left (xy)
  (cons (- (car xy) 1) (cdr xy)))
(def right (xy)
  (cons (+ (car xy) 1) (cdr xy)))
(def up (xy)
  (cons (car xy) (- (cdr xy) 1)))
(def down (xy)
  (cons (car xy) (+ (cdr xy) 1)))
(def movement (xy dir)
  (if (= dir +left+)
      (left xy)
      (if (= dir +right+)
          (right xy)
          (if (= dir +up+)
              (up xy)
              (down xy)))))

(def < (a b)
  (> b a))
(def <= (a b)
  (>= b a))
(def /= (a b)
  (not (= a b)))

(def min (a b) (if (> b a) a b))
(def max (a b) (if (> a b) a b))

(def and (a b)
  (* a b))
(def not (a)
  (- 1 a))
(def or (a b)
  (not (and (not a) (not b))))

(def first (lst)
  (car lst))
(def cadr (lst)
  (car (cdr lst)))
(def cddr (lst)
  (cdr (cdr lst)))
(def caddr (lst)
  (car (cdr (cdr lst))))
(def cdddr (lst)
  (cdr (cdr (cdr lst))))

(def length (lst)
  (if (atom lst)
      0
      (+ (length (cdr lst)) 1)))
(def nth (n lst)
  (if (= n 0)
      (car lst)
      (nth (- n 1) (cdr lst))))
(def mapcar (fn lst)
  (if (atom lst)
      lst
      (cons (fn (car lst)) (mapcar fn (cdr lst)))))
(def reduce (fn lst)
  (if (atom (cdr lst))
      (car lst)
      (reduce fn (cons (fn (car lst) (cadr lst)) (cddr lst)))))
(def remove-if-not (pred lst)
  (if (atom lst)
      lst
      (if (pred (car lst))
          (cons (car lst) (remove-if-not pred (cdr lst)))
          (remove-if-not pred (cdr lst)))))
(def any (pred lst)
  (if (atom lst)
      0
      (if (pred (car lst))
          1
          (any pred (cdr lst)))))

;;; GCC code ends

)))
